module Ringo::Parser

  # LoxParser is  a parser for the Lox language. It takes a series of tokens
  # generated by the LoxScanner and parses the tokens into valid Lox expressions.
  # Any errors are reported via Ringo::error and then the parser synchronizes and
  # continues parsing the tokens.
  #
  # The current grammar is as follows:
  #
  # expression           -> comma
  # comma                -> conditional (',' conditional)* ;
  # conditional          -> equality ('?' expression ':' conditional)? ;
  # equality             -> comparison ( ( "!=" | "==" ) comparison )* ;
  # comparison           -> addition ( ( ">" | ">=" | "<" | "<=" ) addition )* ;
  # addition             -> multiplication ( ( "-" | "+" ) multiplication )* ;
  # multiplication       -> unary ( ( "/" | "*" ) unary )* ;
  # unary                -> ( "!" | "-" ) unary
  #                       | primary ;
  # primary              -> NUMBER | STRING | 'false' | 'true' | 'nil'
  #                       | '(' expression ')'
  class LoxParser
    def initialize(tokens)
      @tokens = tokens
      @current = 0
    end

    # Start the recursive descent parse for the given expression.
    # The AST generated from parsing the tokens is returned, or nil if there
    # was a parse error.
    def parse
      return expression
    rescue Ringo::Errors::ParseError
      return nil
    end

    private

    # Are we at the end of the token list?
    def at_end?
      peek.type == :eof
    end

    # Take a look at the current token.
    def peek
      @tokens.at(@current)
    end

    # Get the previous token.
    def previous
      @tokens.at(@current - 1)
    end

    # Check token_types for a match and advance to the next token if it does match.
    # If it does not match return false.
    def match?(*token_types)
      token_types.each do |type|
        if check?(type)
          advance
          return true
        end
      end

      return false
    end

    # Does the token type match the current token?
    # Return false if at the end of the token list or the token type doesn't match.
    # Return true if the current token's type matches the passed in token_type.
    def check?(token_type)
      return false if at_end?
      return peek.type == token_type
    end

    # Move the token list pointer to the next token and return the previous token.
    def advance
      @current += 1 unless at_end?
      return previous
    end

    # Move the token list pointer to the next token if the current token matches
    # +token_type+, otherwise raise an error with the given +message+.
    def consume(token_type, message)
      return advance if check?(token_type)
      raise error(peek, message)
    end

    # Pass the error token and message to Ringo.error so it will output to STDERR
    # and mark the @@had_error flag.
    # Returns a new Ringo::Errors::ParseError to the LoxParser can deal with the
    # error.
    def error(token, message)
      Ringo.error(token, message)
      return Ringo::Errors::ParseError.new
    end

    # After an error move forward in the token list until a new valid expression
    # can be parsed.
    # As long as the token stream is not at the end move forward until you find
    # a semicolon, or one of the keywords shown.
    def synchronize
      advance

      while !at_end?
        return if previous.type == :semicolon

        case peek.type
        when :class, :fun, :var, :for, :if, :while, :print, :return
          return
        end

        advance
      end
    end

    # Top level Lox grammar rule. This starts the recursive descent parser.
    def expression
      comma
    end

    # Handle the comma operator. It re-uses the Binary expression and groups
    # each pair of expressions.
    def comma
      expr = conditional

      while match?(:comma)
        operator = previous
        right = conditional
        expr = Ringo::Binary.new(expr, operator, right)
      end

      expr
    end

    # Handle the ternary operator 'expr ? expr : expr'.
    def conditional
      expr = equality

      if match?(:question)
        then_branch = expression
        consume(:colon, "Expect ':' after then branch of conditional expression.")
        else_branch = conditional
        expr = Ringo::Conditional.new(expr, then_branch, else_branch)
      end

      expr
    end

    # Handle equality operators: +!=+ and +==+.
    def equality
      expr = comparison

      while match?(:bang_equal, :equal_equal)
        operator = previous
        right = comparison
        expr = Ringo::Binary.new(expr, operator, right)
      end

      expr
    end

    # Handle comparison operators: +>+, +>=+, +<+, +<=+
    def comparison
      expr = addition

      while match?(:greater, :greater_equal, :less, :less_equal)
        operator = previous
        right = addition
        expr = Ringo::Binary.new(expr, operator, right)
      end

      return expr
    end

    # Handle addition and subtraction: +++, +-+.
    def addition
      expr = multiplication

      while match?(:minus, :plus)
        operator = previous
        right = multiplication
        expr = Ringo::Binary.new(expr, operator, right)
      end

      return expr
    end

    # Handle multiplication and division: +/+, +*+
    def multiplication
      expr = unary

      while match?(:slash, :star)
        operator = previous
        right = unary
        expr = Ringo::Binary.new(expr, operator, right)
      end

      return expr
    end

    # Handle unary operations: +!+, +-+
    def unary
      if match?(:bang, :minus)
        operator = previous
        right = unary
        return Ringo::Unary.new(operator, right)
      end

      return primary
    end

    # Handle string, number, grouping and other literals: +true+, +false+, +nil+
    def primary
      return Ringo::Literal.new(false) if match?(:false)
      return Ringo::Literal.new(true)  if match?(:true)
      return Ringo::Literal.new(nil)   if match?(:nil)
      return Ringo::Literal.new(previous.literal) if match?(:number, :string)
      if match?(:lparen)
        expr = expression
        consume(:rparen, 'Expect ) after expression.')
        return Ringo::Grouping.new(expr)
      end

      raise error(peek(), 'Expecting expression.')
    end

  end
end
